// Code generated by Prisma (prisma@1.17.0-beta.30). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { GraphQLSchema } from "graphql";
import { IResolvers } from "graphql-tools/dist/Interfaces";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  position: (where?: PositionWhereInput) => Promise<boolean>;
  submission: (where?: SubmissionWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  topic: (where?: TopicWhereInput) => Promise<boolean>;
  transition: (where?: TransitionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export interface Fragmentable {
  $fragment<T>(fragment: string | Object): T;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;
  $getAbstractResolvers(filterSchema?: GraphQLSchema | string): IResolvers;

  /**
   * Queries
   */

  position: (where: PositionWhereUniqueInput) => Position;
  positions: (
    args?: {
      where?: PositionWhereInput;
      orderBy?: PositionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<PositionNode>>;
  positionsConnection: (
    args?: {
      where?: PositionWhereInput;
      orderBy?: PositionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PositionConnection;
  submission: (where: SubmissionWhereUniqueInput) => Submission;
  submissions: (
    args?: {
      where?: SubmissionWhereInput;
      orderBy?: SubmissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<SubmissionNode>>;
  submissionsConnection: (
    args?: {
      where?: SubmissionWhereInput;
      orderBy?: SubmissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SubmissionConnection;
  tag: (where: TagWhereUniqueInput) => Tag;
  tags: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<TagNode>>;
  tagsConnection: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TagConnection;
  topic: (where: TopicWhereUniqueInput) => Topic;
  topics: (
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<TopicNode>>;
  topicsConnection: (
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TopicConnection;
  transition: (where: TransitionWhereUniqueInput) => Transition;
  transitions: (
    args?: {
      where?: TransitionWhereInput;
      orderBy?: TransitionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<TransitionNode>>;
  transitionsConnection: (
    args?: {
      where?: TransitionWhereInput;
      orderBy?: TransitionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TransitionConnection;
  user: (where: UserWhereUniqueInput) => User;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => Promise<Array<UserNode>>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnection;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createPosition: (data: PositionCreateInput) => Position;
  updatePosition: (
    args: { data: PositionUpdateInput; where: PositionWhereUniqueInput }
  ) => Position;
  updateManyPositions: (
    args: { data: PositionUpdateInput; where?: PositionWhereInput }
  ) => BatchPayload;
  upsertPosition: (
    args: {
      where: PositionWhereUniqueInput;
      create: PositionCreateInput;
      update: PositionUpdateInput;
    }
  ) => Position;
  deletePosition: (where: PositionWhereUniqueInput) => Position;
  deleteManyPositions: (where?: PositionWhereInput) => BatchPayload;
  createSubmission: (data: SubmissionCreateInput) => Submission;
  updateSubmission: (
    args: { data: SubmissionUpdateInput; where: SubmissionWhereUniqueInput }
  ) => Submission;
  updateManySubmissions: (
    args: { data: SubmissionUpdateInput; where?: SubmissionWhereInput }
  ) => BatchPayload;
  upsertSubmission: (
    args: {
      where: SubmissionWhereUniqueInput;
      create: SubmissionCreateInput;
      update: SubmissionUpdateInput;
    }
  ) => Submission;
  deleteSubmission: (where: SubmissionWhereUniqueInput) => Submission;
  deleteManySubmissions: (where?: SubmissionWhereInput) => BatchPayload;
  createTag: (data: TagCreateInput) => Tag;
  updateTag: (
    args: { data: TagUpdateInput; where: TagWhereUniqueInput }
  ) => Tag;
  updateManyTags: (
    args: { data: TagUpdateInput; where?: TagWhereInput }
  ) => BatchPayload;
  upsertTag: (
    args: {
      where: TagWhereUniqueInput;
      create: TagCreateInput;
      update: TagUpdateInput;
    }
  ) => Tag;
  deleteTag: (where: TagWhereUniqueInput) => Tag;
  deleteManyTags: (where?: TagWhereInput) => BatchPayload;
  createTopic: (data: TopicCreateInput) => Topic;
  updateTopic: (
    args: { data: TopicUpdateInput; where: TopicWhereUniqueInput }
  ) => Topic;
  updateManyTopics: (
    args: { data: TopicUpdateInput; where?: TopicWhereInput }
  ) => BatchPayload;
  upsertTopic: (
    args: {
      where: TopicWhereUniqueInput;
      create: TopicCreateInput;
      update: TopicUpdateInput;
    }
  ) => Topic;
  deleteTopic: (where: TopicWhereUniqueInput) => Topic;
  deleteManyTopics: (where?: TopicWhereInput) => BatchPayload;
  createTransition: (data: TransitionCreateInput) => Transition;
  updateTransition: (
    args: { data: TransitionUpdateInput; where: TransitionWhereUniqueInput }
  ) => Transition;
  updateManyTransitions: (
    args: { data: TransitionUpdateInput; where?: TransitionWhereInput }
  ) => BatchPayload;
  upsertTransition: (
    args: {
      where: TransitionWhereUniqueInput;
      create: TransitionCreateInput;
      update: TransitionUpdateInput;
    }
  ) => Transition;
  deleteTransition: (where: TransitionWhereUniqueInput) => Transition;
  deleteManyTransitions: (where?: TransitionWhereInput) => BatchPayload;
  createUser: (data: UserCreateInput) => User;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => User;
  updateManyUsers: (
    args: { data: UserUpdateInput; where?: UserWhereInput }
  ) => BatchPayload;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => User;
  deleteUser: (where: UserWhereUniqueInput) => User;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayload;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  position: (
    where?: PositionSubscriptionWhereInput
  ) => PositionSubscriptionPayloadSubscription;
  submission: (
    where?: SubmissionSubscriptionWhereInput
  ) => SubmissionSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  topic: (
    where?: TopicSubscriptionWhereInput
  ) => TopicSubscriptionPayloadSubscription;
  transition: (
    where?: TransitionSubscriptionWhereInput
  ) => TransitionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type SubmissionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type TransitionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type PositionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type TopicOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface TagUpdateWithoutSubmissionsDataInput {
  name?: String;
  transitions?: TransitionUpdateManyWithoutTagsInput;
  user?: UserUpdateOneWithoutTagsInput;
}

export type PositionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TransitionUpdatestepsInput {
  set?: String[] | String;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  positions_every?: PositionWhereInput;
  positions_some?: PositionWhereInput;
  positions_none?: PositionWhereInput;
  submissions_every?: SubmissionWhereInput;
  submissions_some?: SubmissionWhereInput;
  submissions_none?: SubmissionWhereInput;
  transitions_every?: TransitionWhereInput;
  transitions_some?: TransitionWhereInput;
  transitions_none?: TransitionWhereInput;
  topics_every?: TopicWhereInput;
  topics_some?: TopicWhereInput;
  topics_none?: TopicWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface TransitionUpdatenotesInput {
  set?: String[] | String;
}

export interface TagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  submissions_every?: SubmissionWhereInput;
  submissions_some?: SubmissionWhereInput;
  submissions_none?: SubmissionWhereInput;
  transitions_every?: TransitionWhereInput;
  transitions_some?: TransitionWhereInput;
  transitions_none?: TransitionWhereInput;
  user?: UserWhereInput;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export interface PositionCreateManyWithoutUserInput {
  create?: PositionCreateWithoutUserInput[] | PositionCreateWithoutUserInput;
  connect?: PositionWhereUniqueInput[] | PositionWhereUniqueInput;
}

export interface UserUpdateWithoutTagsDataInput {
  email?: String;
  password?: String;
  positions?: PositionUpdateManyWithoutUserInput;
  submissions?: SubmissionUpdateManyWithoutUserInput;
  transitions?: TransitionUpdateManyWithoutUserInput;
  topics?: TopicUpdateManyWithoutUserInput;
}

export interface PositionCreateWithoutUserInput {
  name: String;
  notes?: PositionCreatenotesInput;
  submissions?: SubmissionCreateManyWithoutPositionInput;
  transitionsFrom?: TransitionCreateManyWithoutStartPositionInput;
  transitionsTo?: TransitionCreateManyWithoutEndPositionInput;
}

export interface PositionUpdateOneWithoutTransitionsFromInput {
  create?: PositionCreateWithoutTransitionsFromInput;
  update?: PositionUpdateWithoutTransitionsFromDataInput;
  upsert?: PositionUpsertWithoutTransitionsFromInput;
  delete?: Boolean;
  connect?: PositionWhereUniqueInput;
}

export interface UserCreateOneWithoutSubmissionsInput {
  create?: UserCreateWithoutSubmissionsInput;
  connect?: UserWhereUniqueInput;
}

export interface PositionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  submissions_every?: SubmissionWhereInput;
  submissions_some?: SubmissionWhereInput;
  submissions_none?: SubmissionWhereInput;
  transitionsFrom_every?: TransitionWhereInput;
  transitionsFrom_some?: TransitionWhereInput;
  transitionsFrom_none?: TransitionWhereInput;
  transitionsTo_every?: TransitionWhereInput;
  transitionsTo_some?: TransitionWhereInput;
  transitionsTo_none?: TransitionWhereInput;
  user?: UserWhereInput;
  AND?: PositionWhereInput[] | PositionWhereInput;
  OR?: PositionWhereInput[] | PositionWhereInput;
  NOT?: PositionWhereInput[] | PositionWhereInput;
}

export interface UserCreateWithoutSubmissionsInput {
  email: String;
  password: String;
  positions?: PositionCreateManyWithoutUserInput;
  transitions?: TransitionCreateManyWithoutUserInput;
  topics?: TopicCreateManyWithoutUserInput;
  tags?: TagCreateManyWithoutUserInput;
}

export interface TopicSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TopicWhereInput;
  AND?: TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput;
  OR?: TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput;
  NOT?: TopicSubscriptionWhereInput[] | TopicSubscriptionWhereInput;
}

export interface UserCreateOneWithoutTagsInput {
  create?: UserCreateWithoutTagsInput;
  connect?: UserWhereUniqueInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface UserCreateWithoutTagsInput {
  email: String;
  password: String;
  positions?: PositionCreateManyWithoutUserInput;
  submissions?: SubmissionCreateManyWithoutUserInput;
  transitions?: TransitionCreateManyWithoutUserInput;
  topics?: TopicCreateManyWithoutUserInput;
}

export interface PositionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PositionWhereInput;
  AND?: PositionSubscriptionWhereInput[] | PositionSubscriptionWhereInput;
  OR?: PositionSubscriptionWhereInput[] | PositionSubscriptionWhereInput;
  NOT?: PositionSubscriptionWhereInput[] | PositionSubscriptionWhereInput;
}

export interface PositionUpdateInput {
  name?: String;
  notes?: PositionUpdatenotesInput;
  submissions?: SubmissionUpdateManyWithoutPositionInput;
  transitionsFrom?: TransitionUpdateManyWithoutStartPositionInput;
  transitionsTo?: TransitionUpdateManyWithoutEndPositionInput;
  user?: UserUpdateOneWithoutPositionsInput;
}

export interface UserCreateInput {
  email: String;
  password: String;
  positions?: PositionCreateManyWithoutUserInput;
  submissions?: SubmissionCreateManyWithoutUserInput;
  transitions?: TransitionCreateManyWithoutUserInput;
  topics?: TopicCreateManyWithoutUserInput;
  tags?: TagCreateManyWithoutUserInput;
}

export interface PositionUpdatenotesInput {
  set?: String[] | String;
}

export interface TransitionCreateInput {
  name: String;
  steps?: TransitionCreatestepsInput;
  notes?: TransitionCreatenotesInput;
  startPosition: PositionCreateOneWithoutTransitionsFromInput;
  endPosition: PositionCreateOneWithoutTransitionsToInput;
  tags?: TagCreateManyWithoutTransitionsInput;
  user: UserCreateOneWithoutTransitionsInput;
}

export interface SubmissionUpdateManyWithoutPositionInput {
  create?:
    | SubmissionCreateWithoutPositionInput[]
    | SubmissionCreateWithoutPositionInput;
  delete?: SubmissionWhereUniqueInput[] | SubmissionWhereUniqueInput;
  connect?: SubmissionWhereUniqueInput[] | SubmissionWhereUniqueInput;
  disconnect?: SubmissionWhereUniqueInput[] | SubmissionWhereUniqueInput;
  update?:
    | SubmissionUpdateWithWhereUniqueWithoutPositionInput[]
    | SubmissionUpdateWithWhereUniqueWithoutPositionInput;
  upsert?:
    | SubmissionUpsertWithWhereUniqueWithoutPositionInput[]
    | SubmissionUpsertWithWhereUniqueWithoutPositionInput;
}

export interface UserUpsertWithoutTopicsInput {
  update: UserUpdateWithoutTopicsDataInput;
  create: UserCreateWithoutTopicsInput;
}

export interface SubmissionUpdateWithWhereUniqueWithoutPositionInput {
  where: SubmissionWhereUniqueInput;
  data: SubmissionUpdateWithoutPositionDataInput;
}

export interface UserUpdateOneWithoutTopicsInput {
  create?: UserCreateWithoutTopicsInput;
  update?: UserUpdateWithoutTopicsDataInput;
  upsert?: UserUpsertWithoutTopicsInput;
  delete?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface SubmissionUpdateWithoutPositionDataInput {
  name?: String;
  steps?: SubmissionUpdatestepsInput;
  notes?: SubmissionUpdatenotesInput;
  tags?: TagUpdateManyWithoutSubmissionsInput;
  user?: UserUpdateOneWithoutSubmissionsInput;
}

export interface TopicUpdateInput {
  name?: String;
  notes?: TopicUpdatenotesInput;
  user?: UserUpdateOneWithoutTopicsInput;
}

export interface SubmissionUpdatestepsInput {
  set?: String[] | String;
}

export interface UserCreateOneWithoutTopicsInput {
  create?: UserCreateWithoutTopicsInput;
  connect?: UserWhereUniqueInput;
}

export interface SubmissionUpdatenotesInput {
  set?: String[] | String;
}

export interface TopicCreateInput {
  name: String;
  notes?: TopicCreatenotesInput;
  user: UserCreateOneWithoutTopicsInput;
}

export interface TagUpdateManyWithoutSubmissionsInput {
  create?:
    | TagCreateWithoutSubmissionsInput[]
    | TagCreateWithoutSubmissionsInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  update?:
    | TagUpdateWithWhereUniqueWithoutSubmissionsInput[]
    | TagUpdateWithWhereUniqueWithoutSubmissionsInput;
  upsert?:
    | TagUpsertWithWhereUniqueWithoutSubmissionsInput[]
    | TagUpsertWithWhereUniqueWithoutSubmissionsInput;
}

export interface TagCreateInput {
  name: String;
  submissions?: SubmissionCreateManyWithoutTagsInput;
  transitions?: TransitionCreateManyWithoutTagsInput;
  user: UserCreateOneWithoutTagsInput;
}

export interface TagUpdateWithWhereUniqueWithoutSubmissionsInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutSubmissionsDataInput;
}

export interface SubmissionUpdateInput {
  name?: String;
  steps?: SubmissionUpdatestepsInput;
  notes?: SubmissionUpdatenotesInput;
  position?: PositionUpdateOneWithoutSubmissionsInput;
  tags?: TagUpdateManyWithoutSubmissionsInput;
  user?: UserUpdateOneWithoutSubmissionsInput;
}

export interface TagUpsertWithWhereUniqueWithoutTransitionsInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutTransitionsDataInput;
  create: TagCreateWithoutTransitionsInput;
}

export interface SubmissionUpsertWithWhereUniqueWithoutPositionInput {
  where: SubmissionWhereUniqueInput;
  update: SubmissionUpdateWithoutPositionDataInput;
  create: SubmissionCreateWithoutPositionInput;
}

export interface TransitionUpdateManyWithoutTagsInput {
  create?:
    | TransitionCreateWithoutTagsInput[]
    | TransitionCreateWithoutTagsInput;
  delete?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
  connect?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
  disconnect?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
  update?:
    | TransitionUpdateWithWhereUniqueWithoutTagsInput[]
    | TransitionUpdateWithWhereUniqueWithoutTagsInput;
  upsert?:
    | TransitionUpsertWithWhereUniqueWithoutTagsInput[]
    | TransitionUpsertWithWhereUniqueWithoutTagsInput;
}

export interface TagUpsertWithWhereUniqueWithoutSubmissionsInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutSubmissionsDataInput;
  create: TagCreateWithoutSubmissionsInput;
}

export interface TransitionUpdateWithWhereUniqueWithoutTagsInput {
  where: TransitionWhereUniqueInput;
  data: TransitionUpdateWithoutTagsDataInput;
}

export interface PositionUpsertWithoutTransitionsFromInput {
  update: PositionUpdateWithoutTransitionsFromDataInput;
  create: PositionCreateWithoutTransitionsFromInput;
}

export interface TransitionUpdateWithoutTagsDataInput {
  name?: String;
  steps?: TransitionUpdatestepsInput;
  notes?: TransitionUpdatenotesInput;
  startPosition?: PositionUpdateOneWithoutTransitionsFromInput;
  endPosition?: PositionUpdateOneWithoutTransitionsToInput;
  user?: UserUpdateOneWithoutTransitionsInput;
}

export interface PositionCreatenotesInput {
  set?: String[] | String;
}

export interface TopicWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  user?: UserWhereInput;
  AND?: TopicWhereInput[] | TopicWhereInput;
  OR?: TopicWhereInput[] | TopicWhereInput;
  NOT?: TopicWhereInput[] | TopicWhereInput;
}

export interface SubmissionCreateWithoutPositionInput {
  name: String;
  steps?: SubmissionCreatestepsInput;
  notes?: SubmissionCreatenotesInput;
  tags?: TagCreateManyWithoutSubmissionsInput;
  user: UserCreateOneWithoutSubmissionsInput;
}

export interface UserUpsertWithoutTagsInput {
  update: UserUpdateWithoutTagsDataInput;
  create: UserCreateWithoutTagsInput;
}

export interface SubmissionCreatenotesInput {
  set?: String[] | String;
}

export interface TransitionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  startPosition?: PositionWhereInput;
  endPosition?: PositionWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  user?: UserWhereInput;
  AND?: TransitionWhereInput[] | TransitionWhereInput;
  OR?: TransitionWhereInput[] | TransitionWhereInput;
  NOT?: TransitionWhereInput[] | TransitionWhereInput;
}

export interface TagCreateWithoutSubmissionsInput {
  name: String;
  transitions?: TransitionCreateManyWithoutTagsInput;
  user: UserCreateOneWithoutTagsInput;
}

export interface PositionUpdateWithoutTransitionsFromDataInput {
  name?: String;
  notes?: PositionUpdatenotesInput;
  submissions?: SubmissionUpdateManyWithoutPositionInput;
  transitionsTo?: TransitionUpdateManyWithoutEndPositionInput;
  user?: UserUpdateOneWithoutPositionsInput;
}

export interface TransitionCreateWithoutTagsInput {
  name: String;
  steps?: TransitionCreatestepsInput;
  notes?: TransitionCreatenotesInput;
  startPosition: PositionCreateOneWithoutTransitionsFromInput;
  endPosition: PositionCreateOneWithoutTransitionsToInput;
  user: UserCreateOneWithoutTransitionsInput;
}

export interface TransitionUpdateManyWithoutEndPositionInput {
  create?:
    | TransitionCreateWithoutEndPositionInput[]
    | TransitionCreateWithoutEndPositionInput;
  delete?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
  connect?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
  disconnect?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
  update?:
    | TransitionUpdateWithWhereUniqueWithoutEndPositionInput[]
    | TransitionUpdateWithWhereUniqueWithoutEndPositionInput;
  upsert?:
    | TransitionUpsertWithWhereUniqueWithoutEndPositionInput[]
    | TransitionUpsertWithWhereUniqueWithoutEndPositionInput;
}

export interface TransitionCreatenotesInput {
  set?: String[] | String;
}

export interface TransitionUpdateWithWhereUniqueWithoutEndPositionInput {
  where: TransitionWhereUniqueInput;
  data: TransitionUpdateWithoutEndPositionDataInput;
}

export interface PositionCreateWithoutTransitionsFromInput {
  name: String;
  notes?: PositionCreatenotesInput;
  submissions?: SubmissionCreateManyWithoutPositionInput;
  transitionsTo?: TransitionCreateManyWithoutEndPositionInput;
  user: UserCreateOneWithoutPositionsInput;
}

export interface TransitionUpdateWithoutEndPositionDataInput {
  name?: String;
  steps?: TransitionUpdatestepsInput;
  notes?: TransitionUpdatenotesInput;
  startPosition?: PositionUpdateOneWithoutTransitionsFromInput;
  tags?: TagUpdateManyWithoutTransitionsInput;
  user?: UserUpdateOneWithoutTransitionsInput;
}

export interface TransitionCreateWithoutEndPositionInput {
  name: String;
  steps?: TransitionCreatestepsInput;
  notes?: TransitionCreatenotesInput;
  startPosition: PositionCreateOneWithoutTransitionsFromInput;
  tags?: TagCreateManyWithoutTransitionsInput;
  user: UserCreateOneWithoutTransitionsInput;
}

export interface TagUpdateManyWithoutTransitionsInput {
  create?:
    | TagCreateWithoutTransitionsInput[]
    | TagCreateWithoutTransitionsInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  update?:
    | TagUpdateWithWhereUniqueWithoutTransitionsInput[]
    | TagUpdateWithWhereUniqueWithoutTransitionsInput;
  upsert?:
    | TagUpsertWithWhereUniqueWithoutTransitionsInput[]
    | TagUpsertWithWhereUniqueWithoutTransitionsInput;
}

export interface TagCreateWithoutTransitionsInput {
  name: String;
  submissions?: SubmissionCreateManyWithoutTagsInput;
  user: UserCreateOneWithoutTagsInput;
}

export interface TagUpdateWithWhereUniqueWithoutTransitionsInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutTransitionsDataInput;
}

export interface SubmissionCreateWithoutTagsInput {
  name: String;
  steps?: SubmissionCreatestepsInput;
  notes?: SubmissionCreatenotesInput;
  position: PositionCreateOneWithoutSubmissionsInput;
  user: UserCreateOneWithoutSubmissionsInput;
}

export interface TagUpdateWithoutTransitionsDataInput {
  name?: String;
  submissions?: SubmissionUpdateManyWithoutTagsInput;
  user?: UserUpdateOneWithoutTagsInput;
}

export interface PositionCreateWithoutSubmissionsInput {
  name: String;
  notes?: PositionCreatenotesInput;
  transitionsFrom?: TransitionCreateManyWithoutStartPositionInput;
  transitionsTo?: TransitionCreateManyWithoutEndPositionInput;
  user: UserCreateOneWithoutPositionsInput;
}

export interface SubmissionUpdateManyWithoutTagsInput {
  create?:
    | SubmissionCreateWithoutTagsInput[]
    | SubmissionCreateWithoutTagsInput;
  delete?: SubmissionWhereUniqueInput[] | SubmissionWhereUniqueInput;
  connect?: SubmissionWhereUniqueInput[] | SubmissionWhereUniqueInput;
  disconnect?: SubmissionWhereUniqueInput[] | SubmissionWhereUniqueInput;
  update?:
    | SubmissionUpdateWithWhereUniqueWithoutTagsInput[]
    | SubmissionUpdateWithWhereUniqueWithoutTagsInput;
  upsert?:
    | SubmissionUpsertWithWhereUniqueWithoutTagsInput[]
    | SubmissionUpsertWithWhereUniqueWithoutTagsInput;
}

export interface TransitionCreateWithoutStartPositionInput {
  name: String;
  steps?: TransitionCreatestepsInput;
  notes?: TransitionCreatenotesInput;
  endPosition: PositionCreateOneWithoutTransitionsToInput;
  tags?: TagCreateManyWithoutTransitionsInput;
  user: UserCreateOneWithoutTransitionsInput;
}

export interface SubmissionUpdateWithWhereUniqueWithoutTagsInput {
  where: SubmissionWhereUniqueInput;
  data: SubmissionUpdateWithoutTagsDataInput;
}

export interface PositionCreateWithoutTransitionsToInput {
  name: String;
  notes?: PositionCreatenotesInput;
  submissions?: SubmissionCreateManyWithoutPositionInput;
  transitionsFrom?: TransitionCreateManyWithoutStartPositionInput;
  user: UserCreateOneWithoutPositionsInput;
}

export interface SubmissionUpdateWithoutTagsDataInput {
  name?: String;
  steps?: SubmissionUpdatestepsInput;
  notes?: SubmissionUpdatenotesInput;
  position?: PositionUpdateOneWithoutSubmissionsInput;
  user?: UserUpdateOneWithoutSubmissionsInput;
}

export interface UserCreateWithoutPositionsInput {
  email: String;
  password: String;
  submissions?: SubmissionCreateManyWithoutUserInput;
  transitions?: TransitionCreateManyWithoutUserInput;
  topics?: TopicCreateManyWithoutUserInput;
  tags?: TagCreateManyWithoutUserInput;
}

export interface PositionUpdateOneWithoutSubmissionsInput {
  create?: PositionCreateWithoutSubmissionsInput;
  update?: PositionUpdateWithoutSubmissionsDataInput;
  upsert?: PositionUpsertWithoutSubmissionsInput;
  delete?: Boolean;
  connect?: PositionWhereUniqueInput;
}

export interface SubmissionCreateWithoutUserInput {
  name: String;
  steps?: SubmissionCreatestepsInput;
  notes?: SubmissionCreatenotesInput;
  position: PositionCreateOneWithoutSubmissionsInput;
  tags?: TagCreateManyWithoutSubmissionsInput;
}

export interface PositionUpdateWithoutSubmissionsDataInput {
  name?: String;
  notes?: PositionUpdatenotesInput;
  transitionsFrom?: TransitionUpdateManyWithoutStartPositionInput;
  transitionsTo?: TransitionUpdateManyWithoutEndPositionInput;
  user?: UserUpdateOneWithoutPositionsInput;
}

export interface TransitionCreateWithoutUserInput {
  name: String;
  steps?: TransitionCreatestepsInput;
  notes?: TransitionCreatenotesInput;
  startPosition: PositionCreateOneWithoutTransitionsFromInput;
  endPosition: PositionCreateOneWithoutTransitionsToInput;
  tags?: TagCreateManyWithoutTransitionsInput;
}

export interface TransitionUpdateManyWithoutStartPositionInput {
  create?:
    | TransitionCreateWithoutStartPositionInput[]
    | TransitionCreateWithoutStartPositionInput;
  delete?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
  connect?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
  disconnect?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
  update?:
    | TransitionUpdateWithWhereUniqueWithoutStartPositionInput[]
    | TransitionUpdateWithWhereUniqueWithoutStartPositionInput;
  upsert?:
    | TransitionUpsertWithWhereUniqueWithoutStartPositionInput[]
    | TransitionUpsertWithWhereUniqueWithoutStartPositionInput;
}

export interface TopicCreateWithoutUserInput {
  name: String;
  notes?: TopicCreatenotesInput;
}

export interface TransitionUpdateWithWhereUniqueWithoutStartPositionInput {
  where: TransitionWhereUniqueInput;
  data: TransitionUpdateWithoutStartPositionDataInput;
}

export interface TagCreateManyWithoutUserInput {
  create?: TagCreateWithoutUserInput[] | TagCreateWithoutUserInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface TransitionUpdateWithoutStartPositionDataInput {
  name?: String;
  steps?: TransitionUpdatestepsInput;
  notes?: TransitionUpdatenotesInput;
  endPosition?: PositionUpdateOneWithoutTransitionsToInput;
  tags?: TagUpdateManyWithoutTransitionsInput;
  user?: UserUpdateOneWithoutTransitionsInput;
}

export interface UserCreateOneWithoutTransitionsInput {
  create?: UserCreateWithoutTransitionsInput;
  connect?: UserWhereUniqueInput;
}

export interface PositionUpdateOneWithoutTransitionsToInput {
  create?: PositionCreateWithoutTransitionsToInput;
  update?: PositionUpdateWithoutTransitionsToDataInput;
  upsert?: PositionUpsertWithoutTransitionsToInput;
  delete?: Boolean;
  connect?: PositionWhereUniqueInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface PositionUpdateWithoutTransitionsToDataInput {
  name?: String;
  notes?: PositionUpdatenotesInput;
  submissions?: SubmissionUpdateManyWithoutPositionInput;
  transitionsFrom?: TransitionUpdateManyWithoutStartPositionInput;
  user?: UserUpdateOneWithoutPositionsInput;
}

export interface SubmissionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  position?: PositionWhereInput;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  user?: UserWhereInput;
  AND?: SubmissionWhereInput[] | SubmissionWhereInput;
  OR?: SubmissionWhereInput[] | SubmissionWhereInput;
  NOT?: SubmissionWhereInput[] | SubmissionWhereInput;
}

export interface UserUpdateOneWithoutPositionsInput {
  create?: UserCreateWithoutPositionsInput;
  update?: UserUpdateWithoutPositionsDataInput;
  upsert?: UserUpsertWithoutPositionsInput;
  delete?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateInput {
  email?: String;
  password?: String;
  positions?: PositionUpdateManyWithoutUserInput;
  submissions?: SubmissionUpdateManyWithoutUserInput;
  transitions?: TransitionUpdateManyWithoutUserInput;
  topics?: TopicUpdateManyWithoutUserInput;
  tags?: TagUpdateManyWithoutUserInput;
}

export interface UserUpdateWithoutPositionsDataInput {
  email?: String;
  password?: String;
  submissions?: SubmissionUpdateManyWithoutUserInput;
  transitions?: TransitionUpdateManyWithoutUserInput;
  topics?: TopicUpdateManyWithoutUserInput;
  tags?: TagUpdateManyWithoutUserInput;
}

export type SubmissionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SubmissionUpdateManyWithoutUserInput {
  create?:
    | SubmissionCreateWithoutUserInput[]
    | SubmissionCreateWithoutUserInput;
  delete?: SubmissionWhereUniqueInput[] | SubmissionWhereUniqueInput;
  connect?: SubmissionWhereUniqueInput[] | SubmissionWhereUniqueInput;
  disconnect?: SubmissionWhereUniqueInput[] | SubmissionWhereUniqueInput;
  update?:
    | SubmissionUpdateWithWhereUniqueWithoutUserInput[]
    | SubmissionUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | SubmissionUpsertWithWhereUniqueWithoutUserInput[]
    | SubmissionUpsertWithWhereUniqueWithoutUserInput;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SubmissionUpdateWithWhereUniqueWithoutUserInput {
  where: SubmissionWhereUniqueInput;
  data: SubmissionUpdateWithoutUserDataInput;
}

export type TopicWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SubmissionUpdateWithoutUserDataInput {
  name?: String;
  steps?: SubmissionUpdatestepsInput;
  notes?: SubmissionUpdatenotesInput;
  position?: PositionUpdateOneWithoutSubmissionsInput;
  tags?: TagUpdateManyWithoutSubmissionsInput;
}

export type TransitionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SubmissionUpsertWithWhereUniqueWithoutUserInput {
  where: SubmissionWhereUniqueInput;
  update: SubmissionUpdateWithoutUserDataInput;
  create: SubmissionCreateWithoutUserInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface TransitionUpdateManyWithoutUserInput {
  create?:
    | TransitionCreateWithoutUserInput[]
    | TransitionCreateWithoutUserInput;
  delete?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
  connect?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
  disconnect?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
  update?:
    | TransitionUpdateWithWhereUniqueWithoutUserInput[]
    | TransitionUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | TransitionUpsertWithWhereUniqueWithoutUserInput[]
    | TransitionUpsertWithWhereUniqueWithoutUserInput;
}

export interface TransitionUpsertWithWhereUniqueWithoutEndPositionInput {
  where: TransitionWhereUniqueInput;
  update: TransitionUpdateWithoutEndPositionDataInput;
  create: TransitionCreateWithoutEndPositionInput;
}

export interface TransitionUpdateWithWhereUniqueWithoutUserInput {
  where: TransitionWhereUniqueInput;
  data: TransitionUpdateWithoutUserDataInput;
}

export interface SubmissionCreateManyWithoutPositionInput {
  create?:
    | SubmissionCreateWithoutPositionInput[]
    | SubmissionCreateWithoutPositionInput;
  connect?: SubmissionWhereUniqueInput[] | SubmissionWhereUniqueInput;
}

export interface TransitionUpdateWithoutUserDataInput {
  name?: String;
  steps?: TransitionUpdatestepsInput;
  notes?: TransitionUpdatenotesInput;
  startPosition?: PositionUpdateOneWithoutTransitionsFromInput;
  endPosition?: PositionUpdateOneWithoutTransitionsToInput;
  tags?: TagUpdateManyWithoutTransitionsInput;
}

export interface TagCreateManyWithoutSubmissionsInput {
  create?:
    | TagCreateWithoutSubmissionsInput[]
    | TagCreateWithoutSubmissionsInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface TransitionUpsertWithWhereUniqueWithoutUserInput {
  where: TransitionWhereUniqueInput;
  update: TransitionUpdateWithoutUserDataInput;
  create: TransitionCreateWithoutUserInput;
}

export interface TransitionCreatestepsInput {
  set?: String[] | String;
}

export interface TopicUpdateManyWithoutUserInput {
  create?: TopicCreateWithoutUserInput[] | TopicCreateWithoutUserInput;
  delete?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
  connect?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
  disconnect?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
  update?:
    | TopicUpdateWithWhereUniqueWithoutUserInput[]
    | TopicUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | TopicUpsertWithWhereUniqueWithoutUserInput[]
    | TopicUpsertWithWhereUniqueWithoutUserInput;
}

export interface TransitionCreateManyWithoutEndPositionInput {
  create?:
    | TransitionCreateWithoutEndPositionInput[]
    | TransitionCreateWithoutEndPositionInput;
  connect?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
}

export interface TopicUpdateWithWhereUniqueWithoutUserInput {
  where: TopicWhereUniqueInput;
  data: TopicUpdateWithoutUserDataInput;
}

export interface SubmissionCreateManyWithoutTagsInput {
  create?:
    | SubmissionCreateWithoutTagsInput[]
    | SubmissionCreateWithoutTagsInput;
  connect?: SubmissionWhereUniqueInput[] | SubmissionWhereUniqueInput;
}

export interface TopicUpdateWithoutUserDataInput {
  name?: String;
  notes?: TopicUpdatenotesInput;
}

export interface TransitionCreateManyWithoutStartPositionInput {
  create?:
    | TransitionCreateWithoutStartPositionInput[]
    | TransitionCreateWithoutStartPositionInput;
  connect?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
}

export interface TopicUpdatenotesInput {
  set?: String[] | String;
}

export interface UserCreateOneWithoutPositionsInput {
  create?: UserCreateWithoutPositionsInput;
  connect?: UserWhereUniqueInput;
}

export interface TopicUpsertWithWhereUniqueWithoutUserInput {
  where: TopicWhereUniqueInput;
  update: TopicUpdateWithoutUserDataInput;
  create: TopicCreateWithoutUserInput;
}

export interface TransitionCreateManyWithoutUserInput {
  create?:
    | TransitionCreateWithoutUserInput[]
    | TransitionCreateWithoutUserInput;
  connect?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
}

export interface TagUpdateManyWithoutUserInput {
  create?: TagCreateWithoutUserInput[] | TagCreateWithoutUserInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  update?:
    | TagUpdateWithWhereUniqueWithoutUserInput[]
    | TagUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | TagUpsertWithWhereUniqueWithoutUserInput[]
    | TagUpsertWithWhereUniqueWithoutUserInput;
}

export interface TopicCreatenotesInput {
  set?: String[] | String;
}

export interface TagUpdateWithWhereUniqueWithoutUserInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutUserDataInput;
}

export interface UserCreateWithoutTransitionsInput {
  email: String;
  password: String;
  positions?: PositionCreateManyWithoutUserInput;
  submissions?: SubmissionCreateManyWithoutUserInput;
  topics?: TopicCreateManyWithoutUserInput;
  tags?: TagCreateManyWithoutUserInput;
}

export interface TagUpdateWithoutUserDataInput {
  name?: String;
  submissions?: SubmissionUpdateManyWithoutTagsInput;
  transitions?: TransitionUpdateManyWithoutTagsInput;
}

export interface SubmissionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SubmissionWhereInput;
  AND?: SubmissionSubscriptionWhereInput[] | SubmissionSubscriptionWhereInput;
  OR?: SubmissionSubscriptionWhereInput[] | SubmissionSubscriptionWhereInput;
  NOT?: SubmissionSubscriptionWhereInput[] | SubmissionSubscriptionWhereInput;
}

export interface TagUpsertWithWhereUniqueWithoutUserInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutUserDataInput;
  create: TagCreateWithoutUserInput;
}

export interface UserUpdateWithoutTopicsDataInput {
  email?: String;
  password?: String;
  positions?: PositionUpdateManyWithoutUserInput;
  submissions?: SubmissionUpdateManyWithoutUserInput;
  transitions?: TransitionUpdateManyWithoutUserInput;
  tags?: TagUpdateManyWithoutUserInput;
}

export interface UserUpsertWithoutPositionsInput {
  update: UserUpdateWithoutPositionsDataInput;
  create: UserCreateWithoutPositionsInput;
}

export interface TagUpdateInput {
  name?: String;
  submissions?: SubmissionUpdateManyWithoutTagsInput;
  transitions?: TransitionUpdateManyWithoutTagsInput;
  user?: UserUpdateOneWithoutTagsInput;
}

export interface PositionUpsertWithoutTransitionsToInput {
  update: PositionUpdateWithoutTransitionsToDataInput;
  create: PositionCreateWithoutTransitionsToInput;
}

export interface TransitionUpsertWithWhereUniqueWithoutTagsInput {
  where: TransitionWhereUniqueInput;
  update: TransitionUpdateWithoutTagsDataInput;
  create: TransitionCreateWithoutTagsInput;
}

export interface UserUpdateOneWithoutTransitionsInput {
  create?: UserCreateWithoutTransitionsInput;
  update?: UserUpdateWithoutTransitionsDataInput;
  upsert?: UserUpsertWithoutTransitionsInput;
  delete?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface SubmissionCreatestepsInput {
  set?: String[] | String;
}

export interface UserUpdateWithoutTransitionsDataInput {
  email?: String;
  password?: String;
  positions?: PositionUpdateManyWithoutUserInput;
  submissions?: SubmissionUpdateManyWithoutUserInput;
  topics?: TopicUpdateManyWithoutUserInput;
  tags?: TagUpdateManyWithoutUserInput;
}

export interface PositionCreateOneWithoutTransitionsFromInput {
  create?: PositionCreateWithoutTransitionsFromInput;
  connect?: PositionWhereUniqueInput;
}

export interface PositionUpdateManyWithoutUserInput {
  create?: PositionCreateWithoutUserInput[] | PositionCreateWithoutUserInput;
  delete?: PositionWhereUniqueInput[] | PositionWhereUniqueInput;
  connect?: PositionWhereUniqueInput[] | PositionWhereUniqueInput;
  disconnect?: PositionWhereUniqueInput[] | PositionWhereUniqueInput;
  update?:
    | PositionUpdateWithWhereUniqueWithoutUserInput[]
    | PositionUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | PositionUpsertWithWhereUniqueWithoutUserInput[]
    | PositionUpsertWithWhereUniqueWithoutUserInput;
}

export interface PositionCreateOneWithoutSubmissionsInput {
  create?: PositionCreateWithoutSubmissionsInput;
  connect?: PositionWhereUniqueInput;
}

export interface PositionUpdateWithWhereUniqueWithoutUserInput {
  where: PositionWhereUniqueInput;
  data: PositionUpdateWithoutUserDataInput;
}

export interface SubmissionCreateManyWithoutUserInput {
  create?:
    | SubmissionCreateWithoutUserInput[]
    | SubmissionCreateWithoutUserInput;
  connect?: SubmissionWhereUniqueInput[] | SubmissionWhereUniqueInput;
}

export interface PositionUpdateWithoutUserDataInput {
  name?: String;
  notes?: PositionUpdatenotesInput;
  submissions?: SubmissionUpdateManyWithoutPositionInput;
  transitionsFrom?: TransitionUpdateManyWithoutStartPositionInput;
  transitionsTo?: TransitionUpdateManyWithoutEndPositionInput;
}

export interface TagCreateWithoutUserInput {
  name: String;
  submissions?: SubmissionCreateManyWithoutTagsInput;
  transitions?: TransitionCreateManyWithoutTagsInput;
}

export interface PositionUpsertWithWhereUniqueWithoutUserInput {
  where: PositionWhereUniqueInput;
  update: PositionUpdateWithoutUserDataInput;
  create: PositionCreateWithoutUserInput;
}

export interface TransitionUpdateInput {
  name?: String;
  steps?: TransitionUpdatestepsInput;
  notes?: TransitionUpdatenotesInput;
  startPosition?: PositionUpdateOneWithoutTransitionsFromInput;
  endPosition?: PositionUpdateOneWithoutTransitionsToInput;
  tags?: TagUpdateManyWithoutTransitionsInput;
  user?: UserUpdateOneWithoutTransitionsInput;
}

export interface UserUpsertWithoutTransitionsInput {
  update: UserUpdateWithoutTransitionsDataInput;
  create: UserCreateWithoutTransitionsInput;
}

export interface SubmissionCreateInput {
  name: String;
  steps?: SubmissionCreatestepsInput;
  notes?: SubmissionCreatenotesInput;
  position: PositionCreateOneWithoutSubmissionsInput;
  tags?: TagCreateManyWithoutSubmissionsInput;
  user: UserCreateOneWithoutSubmissionsInput;
}

export interface TransitionUpsertWithWhereUniqueWithoutStartPositionInput {
  where: TransitionWhereUniqueInput;
  update: TransitionUpdateWithoutStartPositionDataInput;
  create: TransitionCreateWithoutStartPositionInput;
}

export interface TransitionCreateManyWithoutTagsInput {
  create?:
    | TransitionCreateWithoutTagsInput[]
    | TransitionCreateWithoutTagsInput;
  connect?: TransitionWhereUniqueInput[] | TransitionWhereUniqueInput;
}

export interface PositionUpsertWithoutSubmissionsInput {
  update: PositionUpdateWithoutSubmissionsDataInput;
  create: PositionCreateWithoutSubmissionsInput;
}

export interface PositionCreateOneWithoutTransitionsToInput {
  create?: PositionCreateWithoutTransitionsToInput;
  connect?: PositionWhereUniqueInput;
}

export interface UserUpdateOneWithoutSubmissionsInput {
  create?: UserCreateWithoutSubmissionsInput;
  update?: UserUpdateWithoutSubmissionsDataInput;
  upsert?: UserUpsertWithoutSubmissionsInput;
  delete?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface TransitionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TransitionWhereInput;
  AND?: TransitionSubscriptionWhereInput[] | TransitionSubscriptionWhereInput;
  OR?: TransitionSubscriptionWhereInput[] | TransitionSubscriptionWhereInput;
  NOT?: TransitionSubscriptionWhereInput[] | TransitionSubscriptionWhereInput;
}

export interface UserUpdateOneWithoutTagsInput {
  create?: UserCreateWithoutTagsInput;
  update?: UserUpdateWithoutTagsDataInput;
  upsert?: UserUpsertWithoutTagsInput;
  delete?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface SubmissionUpsertWithWhereUniqueWithoutTagsInput {
  where: SubmissionWhereUniqueInput;
  update: SubmissionUpdateWithoutTagsDataInput;
  create: SubmissionCreateWithoutTagsInput;
}

export interface UserUpsertWithoutSubmissionsInput {
  update: UserUpdateWithoutSubmissionsDataInput;
  create: UserCreateWithoutSubmissionsInput;
}

export interface UserUpdateWithoutSubmissionsDataInput {
  email?: String;
  password?: String;
  positions?: PositionUpdateManyWithoutUserInput;
  transitions?: TransitionUpdateManyWithoutUserInput;
  topics?: TopicUpdateManyWithoutUserInput;
  tags?: TagUpdateManyWithoutUserInput;
}

export interface UserCreateWithoutTopicsInput {
  email: String;
  password: String;
  positions?: PositionCreateManyWithoutUserInput;
  submissions?: SubmissionCreateManyWithoutUserInput;
  transitions?: TransitionCreateManyWithoutUserInput;
  tags?: TagCreateManyWithoutUserInput;
}

export interface TopicCreateManyWithoutUserInput {
  create?: TopicCreateWithoutUserInput[] | TopicCreateWithoutUserInput;
  connect?: TopicWhereUniqueInput[] | TopicWhereUniqueInput;
}

export interface TagCreateManyWithoutTransitionsInput {
  create?:
    | TagCreateWithoutTransitionsInput[]
    | TagCreateWithoutTransitionsInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface PositionCreateInput {
  name: String;
  notes?: PositionCreatenotesInput;
  submissions?: SubmissionCreateManyWithoutPositionInput;
  transitionsFrom?: TransitionCreateManyWithoutStartPositionInput;
  transitionsTo?: TransitionCreateManyWithoutEndPositionInput;
  user: UserCreateOneWithoutPositionsInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  password: String;
}

export interface UserPreviousValues
  extends Promise<UserPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface PositionEdgeNode {
  cursor: String;
}

export interface PositionEdge extends Promise<PositionEdgeNode>, Fragmentable {
  node: <T = Position>() => T;
  cursor: () => Promise<String>;
}

export interface PositionEdgeSubscription
  extends Promise<AsyncIterator<PositionEdgeNode>>,
    Fragmentable {
  node: <T = PositionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SubmissionNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  steps: String[];
  notes: String[];
}

export interface Submission extends Promise<SubmissionNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  steps: () => Promise<String[]>;
  notes: () => Promise<String[]>;
  position: <T = Position>() => T;
  tags: <T = Promise<Array<TagNode>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  user: <T = User>() => T;
}

export interface SubmissionSubscription
  extends Promise<AsyncIterator<SubmissionNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  steps: () => Promise<AsyncIterator<String[]>>;
  notes: () => Promise<AsyncIterator<String[]>>;
  position: <T = PositionSubscription>() => T;
  tags: <T = Promise<AsyncIterator<Array<TagSubscription>>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  user: <T = UserSubscription>() => T;
}

export interface AggregatePositionNode {
  count: Int;
}

export interface AggregatePosition
  extends Promise<AggregatePositionNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePositionSubscription
  extends Promise<AsyncIterator<AggregatePositionNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransitionNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  steps: String[];
  notes: String[];
}

export interface Transition extends Promise<TransitionNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  steps: () => Promise<String[]>;
  notes: () => Promise<String[]>;
  startPosition: <T = Position>() => T;
  endPosition: <T = Position>() => T;
  tags: <T = Promise<Array<TagNode>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  user: <T = User>() => T;
}

export interface TransitionSubscription
  extends Promise<AsyncIterator<TransitionNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  steps: () => Promise<AsyncIterator<String[]>>;
  notes: () => Promise<AsyncIterator<String[]>>;
  startPosition: <T = PositionSubscription>() => T;
  endPosition: <T = PositionSubscription>() => T;
  tags: <T = Promise<AsyncIterator<Array<TagSubscription>>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  user: <T = UserSubscription>() => T;
}

export interface TransitionPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  steps: String[];
  notes: String[];
}

export interface TransitionPreviousValues
  extends Promise<TransitionPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  steps: () => Promise<String[]>;
  notes: () => Promise<String[]>;
}

export interface TransitionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransitionPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  steps: () => Promise<AsyncIterator<String[]>>;
  notes: () => Promise<AsyncIterator<String[]>>;
}

export interface AggregateUserNode {
  count: Int;
}

export interface AggregateUser
  extends Promise<AggregateUserNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUserNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdgeNode {
  cursor: String;
}

export interface UserEdge extends Promise<UserEdgeNode>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdgeNode>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayload
  extends Promise<UserSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface PageInfoNode {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfo extends Promise<PageInfoNode>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfoNode>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayloadNode {
  count: Long;
}

export interface BatchPayload extends Promise<BatchPayloadNode>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayloadNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface PositionConnectionNode {}

export interface PositionConnection
  extends Promise<PositionConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<PositionEdgeNode>>>() => T;
  aggregate: <T = AggregatePosition>() => T;
}

export interface PositionConnectionSubscription
  extends Promise<AsyncIterator<PositionConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<PositionEdgeSubscription>>>>() => T;
  aggregate: <T = AggregatePositionSubscription>() => T;
}

export interface TransitionEdgeNode {
  cursor: String;
}

export interface TransitionEdge
  extends Promise<TransitionEdgeNode>,
    Fragmentable {
  node: <T = Transition>() => T;
  cursor: () => Promise<String>;
}

export interface TransitionEdgeSubscription
  extends Promise<AsyncIterator<TransitionEdgeNode>>,
    Fragmentable {
  node: <T = TransitionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PositionNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  notes: String[];
}

export interface Position extends Promise<PositionNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  notes: () => Promise<String[]>;
  submissions: <T = Promise<Array<SubmissionNode>>>(
    args?: {
      where?: SubmissionWhereInput;
      orderBy?: SubmissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transitionsFrom: <T = Promise<Array<TransitionNode>>>(
    args?: {
      where?: TransitionWhereInput;
      orderBy?: TransitionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transitionsTo: <T = Promise<Array<TransitionNode>>>(
    args?: {
      where?: TransitionWhereInput;
      orderBy?: TransitionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  user: <T = User>() => T;
}

export interface PositionSubscription
  extends Promise<AsyncIterator<PositionNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String[]>>;
  submissions: <T = Promise<AsyncIterator<Array<SubmissionSubscription>>>>(
    args?: {
      where?: SubmissionWhereInput;
      orderBy?: SubmissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transitionsFrom: <T = Promise<AsyncIterator<Array<TransitionSubscription>>>>(
    args?: {
      where?: TransitionWhereInput;
      orderBy?: TransitionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transitionsTo: <T = Promise<AsyncIterator<Array<TransitionSubscription>>>>(
    args?: {
      where?: TransitionWhereInput;
      orderBy?: TransitionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  user: <T = UserSubscription>() => T;
}

export interface AggregateTopicNode {
  count: Int;
}

export interface AggregateTopic
  extends Promise<AggregateTopicNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTopicSubscription
  extends Promise<AsyncIterator<AggregateTopicNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PositionSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PositionSubscriptionPayload
  extends Promise<PositionSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Position>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PositionPreviousValues>() => T;
}

export interface PositionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PositionSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PositionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PositionPreviousValuesSubscription>() => T;
}

export interface TopicConnectionNode {}

export interface TopicConnection
  extends Promise<TopicConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<TopicEdgeNode>>>() => T;
  aggregate: <T = AggregateTopic>() => T;
}

export interface TopicConnectionSubscription
  extends Promise<AsyncIterator<TopicConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<TopicEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateTopicSubscription>() => T;
}

export interface PositionPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  notes: String[];
}

export interface PositionPreviousValues
  extends Promise<PositionPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  notes: () => Promise<String[]>;
}

export interface PositionPreviousValuesSubscription
  extends Promise<AsyncIterator<PositionPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String[]>>;
}

export interface TagEdgeNode {
  cursor: String;
}

export interface TagEdge extends Promise<TagEdgeNode>, Fragmentable {
  node: <T = Tag>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdgeNode>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TopicNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  notes: String[];
}

export interface Topic extends Promise<TopicNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  notes: () => Promise<String[]>;
  user: <T = User>() => T;
}

export interface TopicSubscription
  extends Promise<AsyncIterator<TopicNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String[]>>;
  user: <T = UserSubscription>() => T;
}

export interface AggregateSubmissionNode {
  count: Int;
}

export interface AggregateSubmission
  extends Promise<AggregateSubmissionNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSubmissionSubscription
  extends Promise<AsyncIterator<AggregateSubmissionNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubmissionSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SubmissionSubscriptionPayload
  extends Promise<SubmissionSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Submission>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SubmissionPreviousValues>() => T;
}

export interface SubmissionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SubmissionSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SubmissionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SubmissionPreviousValuesSubscription>() => T;
}

export interface SubmissionConnectionNode {}

export interface SubmissionConnection
  extends Promise<SubmissionConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<SubmissionEdgeNode>>>() => T;
  aggregate: <T = AggregateSubmission>() => T;
}

export interface SubmissionConnectionSubscription
  extends Promise<AsyncIterator<SubmissionConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<SubmissionEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateSubmissionSubscription>() => T;
}

export interface SubmissionPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  steps: String[];
  notes: String[];
}

export interface SubmissionPreviousValues
  extends Promise<SubmissionPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  steps: () => Promise<String[]>;
  notes: () => Promise<String[]>;
}

export interface SubmissionPreviousValuesSubscription
  extends Promise<AsyncIterator<SubmissionPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  steps: () => Promise<AsyncIterator<String[]>>;
  notes: () => Promise<AsyncIterator<String[]>>;
}

export interface AggregateTransitionNode {
  count: Int;
}

export interface AggregateTransition
  extends Promise<AggregateTransitionNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransitionSubscription
  extends Promise<AsyncIterator<AggregateTransitionNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransitionSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TransitionSubscriptionPayload
  extends Promise<TransitionSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Transition>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransitionPreviousValues>() => T;
}

export interface TransitionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransitionSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransitionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransitionPreviousValuesSubscription>() => T;
}

export interface TransitionConnectionNode {}

export interface TransitionConnection
  extends Promise<TransitionConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<TransitionEdgeNode>>>() => T;
  aggregate: <T = AggregateTransition>() => T;
}

export interface TransitionConnectionSubscription
  extends Promise<AsyncIterator<TransitionConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<TransitionEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateTransitionSubscription>() => T;
}

export interface TagSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TagSubscriptionPayload
  extends Promise<TagSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Tag>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValues>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface AggregateTagNode {
  count: Int;
}

export interface AggregateTag extends Promise<AggregateTagNode>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTagNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SubmissionEdgeNode {
  cursor: String;
}

export interface SubmissionEdge
  extends Promise<SubmissionEdgeNode>,
    Fragmentable {
  node: <T = Submission>() => T;
  cursor: () => Promise<String>;
}

export interface SubmissionEdgeSubscription
  extends Promise<AsyncIterator<SubmissionEdgeNode>>,
    Fragmentable {
  node: <T = SubmissionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TopicPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
  notes: String[];
}

export interface TopicPreviousValues
  extends Promise<TopicPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  notes: () => Promise<String[]>;
}

export interface TopicPreviousValuesSubscription
  extends Promise<AsyncIterator<TopicPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  notes: () => Promise<AsyncIterator<String[]>>;
}

export interface TopicSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TopicSubscriptionPayload
  extends Promise<TopicSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Topic>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TopicPreviousValues>() => T;
}

export interface TopicSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TopicSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TopicSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TopicPreviousValuesSubscription>() => T;
}

export interface UserNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  password: String;
}

export interface User extends Promise<UserNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  positions: <T = Promise<Array<PositionNode>>>(
    args?: {
      where?: PositionWhereInput;
      orderBy?: PositionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  submissions: <T = Promise<Array<SubmissionNode>>>(
    args?: {
      where?: SubmissionWhereInput;
      orderBy?: SubmissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transitions: <T = Promise<Array<TransitionNode>>>(
    args?: {
      where?: TransitionWhereInput;
      orderBy?: TransitionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  topics: <T = Promise<Array<TopicNode>>>(
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<Array<TagNode>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<UserNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  positions: <T = Promise<AsyncIterator<Array<PositionSubscription>>>>(
    args?: {
      where?: PositionWhereInput;
      orderBy?: PositionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  submissions: <T = Promise<AsyncIterator<Array<SubmissionSubscription>>>>(
    args?: {
      where?: SubmissionWhereInput;
      orderBy?: SubmissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transitions: <T = Promise<AsyncIterator<Array<TransitionSubscription>>>>(
    args?: {
      where?: TransitionWhereInput;
      orderBy?: TransitionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  topics: <T = Promise<AsyncIterator<Array<TopicSubscription>>>>(
    args?: {
      where?: TopicWhereInput;
      orderBy?: TopicOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  tags: <T = Promise<AsyncIterator<Array<TagSubscription>>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TagPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface TagPreviousValues
  extends Promise<TagPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserConnectionNode {}

export interface UserConnection
  extends Promise<UserConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<UserEdgeNode>>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<UserEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface TagConnectionNode {}

export interface TagConnection
  extends Promise<TagConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = Promise<Array<TagEdgeNode>>>() => T;
  aggregate: <T = AggregateTag>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<Array<TagEdgeSubscription>>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TopicEdgeNode {
  cursor: String;
}

export interface TopicEdge extends Promise<TopicEdgeNode>, Fragmentable {
  node: <T = Topic>() => T;
  cursor: () => Promise<String>;
}

export interface TopicEdgeSubscription
  extends Promise<AsyncIterator<TopicEdgeNode>>,
    Fragmentable {
  node: <T = TopicSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TagNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface Tag extends Promise<TagNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  submissions: <T = Promise<Array<SubmissionNode>>>(
    args?: {
      where?: SubmissionWhereInput;
      orderBy?: SubmissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transitions: <T = Promise<Array<TransitionNode>>>(
    args?: {
      where?: TransitionWhereInput;
      orderBy?: TransitionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  user: <T = User>() => T;
}

export interface TagSubscription
  extends Promise<AsyncIterator<TagNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  submissions: <T = Promise<AsyncIterator<Array<SubmissionSubscription>>>>(
    args?: {
      where?: SubmissionWhereInput;
      orderBy?: SubmissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transitions: <T = Promise<AsyncIterator<Array<TransitionSubscription>>>>(
    args?: {
      where?: TransitionWhereInput;
      orderBy?: TransitionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  user: <T = UserSubscription>() => T;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Type Defs
 */

export const prisma: Prisma;
